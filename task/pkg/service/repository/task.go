package repository

import (
	"cloud.google.com/go/firestore"
	"context"
	"fmt"
	middleware "jakubjano/todolist/task/internal/auth"
	"reflect"
	"time"
)

type FSTaskInterface interface {
	Create(ctx context.Context, in Task) (Task, error)
	Get(ctx context.Context, taskID string) (Task, error)
	Update(ctx context.Context, fields map[string]interface{}, docID string) (Task, error)
	Delete(ctx context.Context, taskID string) error
	//Update(ctx context.Context, newTask Task, docID string) (Task, error)
}

type FSTask struct {
	fs *firestore.CollectionRef
}

func NewFSTask(fs *firestore.CollectionRef) *FSTask {
	return &FSTask{
		fs: fs,
	}
}

func (f *FSTask) Create(ctx context.Context, in Task) (Task, error) {
	task, _, err := f.fs.Add(ctx, in)
	if err != nil {
		return Task{}, err
	}
	err = f.updateFields(ctx, task.ID)
	if err != nil {
		return Task{}, err
	}
	in.TaskID = task.ID
	return in, nil
}

func (f *FSTask) Get(ctx context.Context, taskID string) (Task, error) {
	doc, err := f.fs.Doc(taskID).Get(ctx)
	if err != nil {
		return Task{}, err
	}
	task := Task{}
	err = doc.DataTo(&task)
	if err != nil {
		return Task{}, err
	}
	return task, nil
}

// Experimental Update function - I am not sure what approach is the best one
// Don't know if doc.Set() with .mergeAll updates only not null values from update request
func (f *FSTask) Update(ctx context.Context, fields map[string]interface{}, docID string) (Task, error) {
	for field, value := range fields {
		switch v := value.(type) {
		case int64:
			// doesn't work without type assertion
			// probably caused by the interface{} type
			if value.(int64) == 0 {
				fmt.Println(value)
				continue
			}
		case string:
			if value == "" {
				fmt.Println(value)
				continue
			}
		default:
			fmt.Printf("Some other type: %v \n", v)
			fmt.Println(reflect.TypeOf(value))
		}
		// returns error if document with given id does not exist
		_, err := f.fs.Doc(docID).Update(ctx, []firestore.Update{
			{
				Path:  field,
				Value: value,
			},
		})
		if err != nil {
			return Task{}, err
		}
	}

	updatedTask, err := f.Get(ctx, docID)
	if err != nil {
		return Task{}, err
	}
	return updatedTask, nil
}

func (f *FSTask) Delete(ctx context.Context, taskID string) error {
	_, err := f.fs.Doc(taskID).Delete(ctx)
	if err != nil {
		return err
	}
	return nil
}

//func (f *FSTask) Update(ctx context.Context, newTask Task, docID string) (Task, error) {
//	// merge all option can only be passed with map data
//	_, err := f.fst.Doc(docID).Set(ctx, newTask, firestore.MergeAll)
//	if err != nil {
//		return Task{}, err
//	}
//	updatedTask, err := f.Get(ctx, docID)
//	if err != nil {
//		return Task{}, err
//	}
//	return updatedTask, nil
//}

// adds autogenerated document ID and unix time to the document fields from the Task type
func (f *FSTask) updateFields(ctx context.Context, docID string) error {
	ctxUser := ctx.Value("user").(*middleware.UserContext)
	_, err := f.fs.Doc(docID).Update(ctx, []firestore.Update{
		{
			Path:  "taskID",
			Value: docID,
		},
		{
			Path:  "createdAt",
			Value: time.Now().Unix(),
		},
		{
			Path:  "userID",
			Value: ctxUser.UserID,
		},
	})
	if err != nil {
		return err
	}
	return nil
}

func (f *FSTask) FilterTasks() {

}
