package repository

import (
	"cloud.google.com/go/firestore"
	"context"
	"log"
	"time"
)

type FSTaskInterface interface {
	Create(ctx context.Context, in Task) (Task, error)
	Get(ctx context.Context, TaskID string) (Task, error)
	Update(ctx context.Context, fields map[string]interface{}, docID string) (Task, error)
	Delete(ctx context.Context, TaskID string) error
	//Update(ctx context.Context, newTask Task, docID string) (Task, error)
}

type FSTask struct {
	fst *firestore.CollectionRef
}

func NewFSTask(fst *firestore.CollectionRef) *FSTask {
	return &FSTask{
		fst: fst,
	}
}

func (f *FSTask) Create(ctx context.Context, in Task) (Task, error) {
	task, _, err := f.fst.Add(ctx, in)
	if err != nil {
		log.Fatalf("error creating document in firestore: %v \n", err)
	}
	err = f.updateFields(ctx, task.ID)
	if err != nil {
		log.Fatalf("error setting TaskID with firestore update method: %v \n", err)
	}
	in.TaskID = task.ID
	return in, nil
}

func (f *FSTask) Get(ctx context.Context, TaskID string) (Task, error) {
	doc, err := f.fst.Doc(TaskID).Get(ctx)
	if err != nil {
		log.Fatalf("error getting document from firestore: %v \n", err)
		return Task{}, err
	}
	task := Task{}
	err = doc.DataTo(&task)
	if err != nil {
		log.Fatalf("error converting document ref from Firestore to type Task type: %v \n", err)
		return Task{}, err
	}
	return task, nil
}

// Experimental Update function - I am not sure what approach is the best one
// Don't know if doc.Set() with .mergeAll updates only not null values from update request
func (f *FSTask) Update(ctx context.Context, fields map[string]interface{}, docID string) (Task, error) {

	for field, value := range fields {
		if value == "" {
			continue
		}
		// returns error if document with given id does not exist
		_, err := f.fst.Doc(docID).Update(ctx, []firestore.Update{
			{
				Path:  field,
				Value: value,
			},
		})
		if err != nil {
			log.Fatalf("error updating fields: %v \n", err)
			return Task{}, err
		}
	}
	updatedTask, err := f.Get(ctx, docID)
	if err != nil {
		log.Fatalf("error getting updated task: %v \n", err)
	}
	return updatedTask, nil
}

func (f *FSTask) Delete(ctx context.Context, TaskID string) error {
	_, err := f.fst.Doc(TaskID).Delete(ctx)
	if err != nil {
		log.Fatalf("error deleting document with id %s : %v  \n", TaskID, err)
	}
	return nil
}

//func (f *FSTask) Update(ctx context.Context, newTask Task, docID string) (Task, error) {
//	// merge all option can only be passed with map data
//	_, err := f.fst.Doc(docID).Set(ctx, newTask, firestore.MergeAll)
//	if err != nil {
//		log.Fatalf("error updating task with .Set: %v \n", err)
//		return Task{}, err
//	}
//	updatedTask, err := f.Get(ctx, docID)
//	if err != nil {
//		log.Fatalf("error getting newly updated task with .Set: %v \n", err)
//		return Task{}, err
//	}
//	return updatedTask, nil
//}

// adds autogenerated document ID and unix time to the document fields from the Task type
func (f *FSTask) updateFields(ctx context.Context, docID string) error {
	f.fst.Doc(docID).Update(ctx, []firestore.Update{
		{
			Path:  "TaskID",
			Value: docID,
		},
		{
			Path:  "CreatedAt",
			Value: time.Now().Unix(),
		},
	})
	return nil
}

func (f *FSTask) FilterTasks() {

}
